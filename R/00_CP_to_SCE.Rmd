---
title: "CellProfiler_to_SingleCellExperiment"
author: "Jana Fischer"
date: "1/27/2020"
output: html_document
---

Read in the single-cell data generated by CellProfiler and convert to SingleCellExperiment structure including sample and patient metadata.

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r, include=FALSE}
library(data.table)
library(plyr)
library(SingleCellExperiment)
library(ggplot2)
library(stringr)
library(EBImage)
library(ggridges)

censor_dat = function(x, quant = 0.999, symmetric=F){
  if (symmetric){
    lower_quant = (1-quant)/2
    quant = quant+lower_quant
  }
  q = stats::quantile(x,quant)
  x[x>q] = q

  if(symmetric){
    q = stats::quantile(x, lower_quant)
    x[x < q] = q
  }
  return(x)
}
```

Extract single-cell data from CellProfiler output format and clean
```{r}
#Read CP output
cells = fread('/mnt/ZTMA_21_25_26/cpout/cell.csv',header = T)

#Marker channels
cp_measurevars = c('MeanIntensity_FullStack')
measurevar = colnames(cells)[grep(paste(paste0(cp_measurevars,'_'),collapse='|'), colnames(cells), ignore.case=TRUE)]

#Additional columns of interest
cp_idvars = c('ImageNumber', 'ObjectNumber','AreaShape_Area','AreaShape_Eccentricity','AreaShape_Extent', 'AreaShape_MajorAxisLength', 'AreaShape_MinorAxisLength',"AreaShape_Center_X","AreaShape_Center_Y","Neighbors_PercentTouching_4","Neighbors_NumberOfNeighbors_4")

#Convert marker channels to long format
cells_long = melt.data.table(cells, id.vars = cp_idvars, variable.factor = F, measure.vars = measurevar)
cells_long[,channel := as.numeric(sub(".*_c", "",.BY)), by = "variable"]

#Rescale (necessary due to CP conversion)
cells_long[,value := value * 65535]

#Censore data at the 99th percentile to account for outliers
cells_long[,value := censor_dat(value,0.99), by=channel]

#Normalize between 0 and 1 (use 99th percentile normalization to account for outliers)
cells_long[,perc99 := quantile(value,0.99), by=channel]
cells_long[,perc_norm := value/perc99]
cells_long[perc_norm < 0, perc_norm := 0 ]
cells_long[perc_norm > 1, perc_norm := 1 ]

#Arcsinh transform (cofactor 1)
cells_long[,counts_arcsinh := asinh(value), by = 'channel']
cells = NULL

```

Match channel numbers to marker names and clean image metadata
```{r}
#Load pannel and make sure only one marker name is used for the same channel (in case of multiple targets in same channel)
panel = fread('/mnt/ZTMA_21_25_26/Panel.csv',header = T)
panel = panel[!duplicated(panel$channel),]
panel[,Target := paste0(Metal_Tag,'_',Target)]

#Load image metadata from CP output
image_meta = fread('/mnt/ZTMA_21_25_26/cpout/Image.csv',header = T,stringsAsFactors = F)
cols = c('FileName_CellImage','FileName_FullStack','Width_FullStack','Height_FullStack','ImageNumber',"Metadata_Description")
image_meta_short = subset(image_meta,, cols)
image_meta_short[,core := sub("_ac_full.tif.*","",.BY),by = "FileName_FullStack"]
image_meta_short[,area_square := Width_FullStack * Height_FullStack]
image_meta_short[,UBTMA_location := strsplit(Metadata_Description,"_")[[1]][3],by = "Metadata_Description"]
image_meta = NULL

#Merge with circular tissue area for more exact density calculations
area = fread('/mnt/ZTMA_21_25_26/cpout/AreaTissue.csv')
image_meta_short = merge(image_meta_short,area[,c('ImageNumber','AreaShape_Area')],by = 'ImageNumber',all.x = T)
area = NULL

#Failed circular tissue area calculations are usually on cores that were not fully acquired because of measuring interruptions (use square areas in those cases)
image_meta_short[is.na(AreaShape_Area), AreaShape_Area := area_square]
setnames(image_meta_short,"AreaShape_Area","AreaTissue")

#Merge single-cell data with meaningful core and marker names from image metadata
cells_long = merge(cells_long, image_meta_short[,c("ImageNumber", "core","UBTMA_location")], by = 'ImageNumber')
cells_long$channel = mapvalues(cells_long$channel,panel$channel,panel$Target)
cells_long[,id := paste(.BY,collapse =  "_"), by=.(core,ObjectNumber)]

#Read in cell IDs on the edge of the core identified by CP pipeline (potentially special cases for spatial analyses)
edge = fread('/mnt/ZTMA_21_25_26/cpout/Object relationships.csv')
edge = edge[Relationship == "Parent",] #All cells that are within the parent non-edge object
edge = unique(edge[,c('First Image Number','Second Object Number')])
names(edge) = c("ImageNumber","ObjectNumber")
edge$edge_bool = 0
#Merge with cells_long and fill edge_bool for remaining cells (on edge) with 1
cells_long = merge(cells_long,edge , by = c("ImageNumber","ObjectNumber"),all.x = T)
cells_long[is.na(edge_bool),edge_bool := 1]
edge = NULL

```

Clean patient metadata, only run once in beginning and work with cleaned data after
```{r, eval = F}
validation_metadata = fread('/mnt/ZTMA_21_25_26/Master_ZTMAbreastcancer_Charlotte2.csv',header = T)

#PID matching because correct PIDs were not in original metadata received from clinica
PID21 = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/ValidationCohort/TMA21_PID.csv',header = T)
PID25 = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/ValidationCohort/TMA25_PID.csv',header = T)
PID26 = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/ValidationCohort/TMA26_PID.csv',header = T)
PID27 = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/ValidationCohort/TMA27_PID.csv',header = T)

z21 = validation_metadata[ArrayNr == 'ZTMA21',]
z25 = validation_metadata[ArrayNr == 'ZTMA25',]
z26 = validation_metadata[ArrayNr == 'ZTMA26',]
z27 = validation_metadata[ArrayNr == 'ZTMA27',]
z21 = merge(z21,unique(PID21[,c('PatientenID','SpotNr')]),by = 'SpotNr')
z25 = merge(z25,unique(PID25[,c('PatientenID','SpotNr')]),by = 'SpotNr')
z26 = merge(z26,unique(PID26[,c('PatientenID','SpotNr')]),by = 'SpotNr')
z27 = merge(z27,unique(PID27[,c('PatientenID','SpotNr')]),by = 'SpotNr')
z21 = z21[order(PatientenID)]
z25 = z25[order(PatientenID)]
z26 = z26[order(PatientenID)]
z27 = z27[order(PatientenID)]
z21 = z21[,c('PatientenID',colnames(z21)[colnames(z21) != 'PatientenID']),with = F]
z25 = z25[,c('PatientenID',colnames(z25)[colnames(z25) != 'PatientenID']),with = F]
z26 = z26[,c('PatientenID',colnames(z26)[colnames(z26) != 'PatientenID']),with = F]
z27 = z27[,c('PatientenID',colnames(z27)[colnames(z27) != 'PatientenID']),with = F]

validation_metadata =rbind(z21,z25,z26,z27)
names(validation_metadata)[names(validation_metadata) == 'SpotNr'] = 'UBTMA_location'

#Combine with updated survival data (received from clinics later on)
update = fread('/home/ubuntu/tmp/server_homes/janaf/Data/2019/ValidationCohort/TMA21_BrCa_survival_updated_2019.csv',header = T)
names(update)[names(update) == 'SpotNr'] = 'UBTMA_location'
validation_metadata = merge(validation_metadata,update[,c('UBTMA_location','Livestatus1dead','Monate','Livestatus1censored','EDZP','DXname','PID','Patientenstatus','Datum Follow-up','ArrayNr')],by = c('ArrayNr','UBTMA_location'),all.x = T)
validation_metadata$EDZP = as.Date(validation_metadata$EDZP)
validation_metadata$`Datum Follow-up`[validation_metadata$`Datum Follow-up` == ""] = NA
validation_metadata$`Datum Follow-up` = as.Date(validation_metadata$`Datum Follow-up`)

#Calculate survival time in months based on diagnosis and follow up date
validation_metadata$OSnew<- difftime(validation_metadata$`Datum Follow-up` ,validation_metadata$EDZP , units = c("weeks"))
validation_metadata$OSnew = round(as.numeric(validation_metadata$OSnew)/4)

#Make sure updated survival data is spread to all cores of same patient
new_surv = unique(validation_metadata[,c('PatientenID','OSnew')])
new_surv = new_surv[!is.na(OSnew),]
new_surv = new_surv[order(PatientenID)]

validation_metadata = merge(validation_metadata,new_surv,by = 'PatientenID',all.x = T)
names(validation_metadata)[names(validation_metadata) == "OSnew.y"] = "OSfinal"

validation_metadata$OSfinal[is.na(validation_metadata$OSfinal)] = validation_metadata$Monate[is.na(validation_metadata$OSfinal)]

#Use survival data out of updated and old data because the updated data didn't include the survival times for the patients that didn't get updated
validation_metadata$OSfinal[is.na(validation_metadata$OSfinal)] = validation_metadata$OS[is.na(validation_metadata$OSfinal)]
validation_metadata[Status_OS == "censored",Status_OS := 1]
validation_metadata[Status_OS == "death",Status_OS := 0]
validation_metadata[Status_OS == "#NULL!",Status_OS := NA]
validation_metadata[,Status_OS := as.numeric(Status_OS)]
validation_metadata$Livestatus1censored[is.na(validation_metadata$Livestatus1censored)] = validation_metadata$Status_OS[is.na(validation_metadata$Livestatus1censored)]

#Remove unnecessary columns
validation_metadata = validation_metadata[,-c("ID","OS","Monate","EDZP","PID","Patientenstatus","Datum Follow-up","OSnew.x")]

#Clean column names
setnames(validation_metadata,"PatientenID","PID")
setnames(validation_metadata,"OSfinal","OS")

fwrite(validation_metadata,"/mnt/ZTMA_21_25_26/Metadata_cleaned.csv", col.names = T)

```

Read in cleaned patient metadata
```{r}
Patient_metadata = fread("/mnt/ZTMA_21_25_26/Metadata_cleaned.csv",header = T)

```

Convert to single cell experiment
```{r}
#Dcast single-cell data back to wide format
idcols = rev(colnames(cells_long)[!colnames(cells_long) %in% c('channel', 'perc_norm', 'variable','perc99','value','counts_arcsinh','stack','measure','measuretype','value', 'ImageNumber','ObjectNumber')])

#use 01 normalized data
dat_norm = dcast.data.table(cells_long, formula = paste0(paste(idcols, collapse = '+'), '~', 'channel'), value.var = 'perc_norm')

#use raw counts
dat_raw = dcast.data.table(cells_long, formula = paste0(paste(idcols, collapse = '+'), '~', 'channel'), value.var = 'value')

#use arcsinh transformed data for checking sinal drop bellow
dat_arcsinh = dcast.data.table(cells_long, formula = 'id~channel', value.var = 'counts_arcsinh')
cells_long = NULL


#Convert single-cell expression data to SCE

#Normalized data
rnames = dat_norm$id
dat_wide_norm = as.matrix(dat_norm[,-c('id','UBTMA_location','core','edge_bool','Neighbors_NumberOfNeighbors_4','Neighbors_PercentTouching_4','AreaShape_Center_Y','AreaShape_Center_X','AreaShape_MinorAxisLength','AreaShape_MajorAxisLength','AreaShape_Extent','AreaShape_Eccentricity','AreaShape_Area')])
rownames(dat_wide_norm) = rnames
dat_wide_norm = t(dat_wide_norm)

#Raw data
rnames = dat_raw$id
dat_wide_raw = as.matrix(dat_raw[,-c('id','UBTMA_location','core','edge_bool','Neighbors_NumberOfNeighbors_4','Neighbors_PercentTouching_4','AreaShape_Center_Y','AreaShape_Center_X','AreaShape_MinorAxisLength','AreaShape_MajorAxisLength','AreaShape_Extent','AreaShape_Eccentricity','AreaShape_Area')])
rownames(dat_wide_raw) = rnames
dat_wide_raw = t(dat_wide_raw)
dat_raw = NULL

sce <- SingleCellExperiment(assays = list(counts = dat_wide_norm, raw = dat_wide_raw))
dat_wide_norm = NULL
dat_wide_raw = NULL

#Prepare single-cell metadata to add to colData of SCE
colD = unique(dat_norm[,c('id','UBTMA_location','core','edge_bool','Neighbors_NumberOfNeighbors_4','Neighbors_PercentTouching_4','AreaShape_Center_Y','AreaShape_Center_X','AreaShape_MinorAxisLength','AreaShape_MajorAxisLength','AreaShape_Extent','AreaShape_Eccentricity','AreaShape_Area')])
colD$UBTMA_location = as.numeric(colD$UBTMA_location)
colD$ArrayNr = substr(colD$core,1,6)
dat_norm = NULL

#Add patient metadata
colD = merge(colD,Patient_metadata, by = c('UBTMA_location','ArrayNr'),all.x = T)

#Add image metadata
colD = merge(colD,image_meta_short[,-c('UBTMA_location')], by = c('core'),all.x = T)

#Add colData to sce
colD = colD[order(match(id,colnames(sce))),]
colD$PID = as.factor(colD$PID)
rnames = colD$id
colD = DataFrame(colD[,-'id'])
rownames(colD) = rnames
colData(sce) = colD

#Save out SCE
saveRDS(sce, file = '/mnt/ZTMA_21_25_26/analysis/SCE.rds', ascii = FALSE)

```

Quality control
```{r}
sce = readRDS('/mnt/ZTMA_21_25_26/analysis/SCE.rds')

#Number cells per core
cells_core = as.data.frame(table(colData(sce)[c('core')]))
ggplot(cells_core,aes(x = Freq))+geom_density()

#Cell areas per core
area_cells = as.data.table(colData(sce)[c('core','AreaShape_Area')])
area_cells[,avg_area_cells := mean(AreaShape_Area),by = "core"]
area_cells = unique(area_cells[,-c('AreaShape_Area')])
ggplot(area_cells,aes(x = avg_area_cells))+geom_density()

#Images to visually inspect to check for bad segmentation -> decided to exclude very small or big cells from analysis in order to keep the well segmented cells of images with some mis-segmentations
big = area_cells[area_cells$avg_area_cells > 150]
small = area_cells[area_cells$avg_area_cells < 30]

#Tissue areas per core
area_tissue = unique(as.data.table(colData(sce)[c('core','AreaTissue')]))
ggplot(area_tissue,aes(x = AreaTissue))+geom_density()

#Cell density per core
names(cells_core)[1] = 'core'
density = merge(area_tissue,cells_core,by = 'core')
density[,dens := Freq/AreaTissue]
ggplot(density,aes(x = dens))+geom_density()

#Visualize certain masks
for (i in small$core){
  path = '/mnt/ZTMA_21_25_26/cpout/'
  all_files = list.files(path)
  file = all_files[str_detect(all_files,i)]

  mask = readImage(paste0(path,'/',file))
  imageData(mask) = imageData(mask)*(2^16-1)
  
  #Display mask
  nmask = bwlabel(mask)
  print(display(nmask, all=TRUE))
}
display(colorLabels(mask))

```

Check for signal drop over time
```{r}
#Use arcsinh transformed data and extract acquisition batch info from core name
dat_arcsinh[,ArrayNr_batch := sub("_s.*", "",id)]

#Melt to long format for plotting
dat_long = melt.data.table(dat_arcsinh,id.var = c("id","ArrayNr_batch"))

#Set batch colors
TMAcols = c(colors()[grep("steelblue",colors())][1:4],
            colors()[grep("purple",colors())][1:4],
            colors()[grep("steelblue",colors())][5:7])

#Plot density plots for each marker for the different batches -> no consistent signal drop here, only some biological variation
pdf('/home/ubuntu/tmp/server_homes/janaf/Data/2020/ZTMA21_25_26/R_dat/check_signal_drop_density.pdf',width = 40,height = 20)
ggplot(dat_long,aes(x = value,y = ArrayNr_batch,fill = ArrayNr_batch))+geom_density_ridges(alpha = 0.5)+
  facet_wrap(~variable,scale = "free")+
  scale_fill_manual(values = TMAcols)
dev.off()
```
